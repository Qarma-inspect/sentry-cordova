{"version":3,"file":"cordova.js","sourceRoot":"","sources":["../../../src/js/transports/cordova.ts"],"names":[],"mappings":";;;AAAA,8DAA+E;AAE/E,uCAA0E;AAE1E,sCAAoC;AAEpC;;;GAGG;AACH;IAOE,0BAAY,OAAyB;QANrC,4CAA4C;QACzB,YAAO,GAA4B,IAAI,qBAAa,CAAC,EAAE,CAAC,CAAC;QAM1E,IAAI,qBAAa,EAAE,EAAE;YACnB,IAAI,CAAC,kBAAkB,GAAG,IAAI,2BAAc,CAAC,OAAO,CAAC,CAAC;SACvD;aAAM;YACL,IAAI,CAAC,kBAAkB,GAAG,IAAI,yBAAY,CAAC,OAAO,CAAC,CAAC;SACrD;IACH,CAAC;IAED;;OAEG;IACI,oCAAS,GAAhB,UAAiB,KAAY;QAC3B,IAAI,gBAAM,CAAC,0BAA0B,EAAE,EAAE;YACvC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,EAAE;gBAC3B,OAAO,OAAO,CAAC,MAAM,CAAC,IAAI,mBAAW,CAAC,iDAAiD,CAAC,CAAC,CAAC;aAC3F;YACD,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,gBAAM,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC;SAClD;QAED,OAAO,IAAI,CAAC,kBAAkB,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;IAClD,CAAC;IAED;;OAEG;IACI,gCAAK,GAAZ,UAAa,OAAgB;QAC3B,OAAO,OAAO,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,OAAO,CAAC,EAAE,IAAI,CAAC,kBAAkB,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC,IAAI,CACrF,UAAC,EAA+B;gBAA/B,KAAA,qBAA+B,EAA9B,aAAa,QAAA,EAAE,cAAc,QAAA;YAAM,OAAA,aAAa,IAAI,cAAc;QAA/B,CAA+B,CACrE,CAAC;IACJ,CAAC;IACH,uBAAC;AAAD,CAAC,AArCD,IAqCC;AArCY,4CAAgB","sourcesContent":["import { FetchTransport, XHRTransport } from '@sentry/browser/dist/transports';\nimport { Event, Response, Transport, TransportOptions } from '@sentry/types';\nimport { PromiseBuffer, SentryError, supportsFetch } from '@sentry/utils';\n\nimport { NATIVE } from '../wrapper';\n\n/**\n * Uses the native transport if available, otherwise falls back to Fetch/XHR transport.\n * @see NATIVE.SUPPORTS_NATIVE_TRANSPORT for platforms with native transport\n */\nexport class CordovaTransport implements Transport {\n  /** A simple buffer holding all requests. */\n  protected readonly _buffer: PromiseBuffer<Response> = new PromiseBuffer(30);\n\n  /** Fallback transport uses if native transport is not available */\n  private _fallbackTransport: Transport;\n\n  constructor(options: TransportOptions) {\n    if (supportsFetch()) {\n      this._fallbackTransport = new FetchTransport(options);\n    } else {\n      this._fallbackTransport = new XHRTransport(options);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public sendEvent(event: Event): PromiseLike<Response> {\n    if (NATIVE.isNativeTransportAvailable()) {\n      if (!this._buffer.isReady()) {\n        return Promise.reject(new SentryError('Not adding Promise due to buffer limit reached.'));\n      }\n      return this._buffer.add(NATIVE.sendEvent(event));\n    }\n\n    return this._fallbackTransport.sendEvent(event);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public close(timeout?: number): PromiseLike<boolean> {\n    return Promise.all([this._buffer.drain(timeout), this._fallbackTransport.close()]).then(\n      ([bufferDrained, fallbackClosed]) => bufferDrained && fallbackClosed\n    );\n  }\n}\n"]}